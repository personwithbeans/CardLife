<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Quantum Life Simulator - Matrix Edition</title>
    <style>
        body {
            background-color: #0a0a0a;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #simulation {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            border: 2px solid #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            background-color: rgba(0, 17, 0, 0.8);
        }
        h2 {
            text-shadow: 0 0 5px #00ff00;
            letter-spacing: 2px;
            margin: 10px 0;
        }
        .grid-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 90vw;
            max-height: 70vh;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
        }
        canvas {
            width: 100%;
            height: 100%;
        }
        .controls {
            display: flex;
            gap: 15px;
            margin: 15px 0;
        }
        button {
            padding: 8px 16px;
            cursor: pointer;
            background-color: transparent;
            color: #00ff00;
            border: 1px solid #00ff00;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-transform: uppercase;
            text-shadow: 0 0 3px #00ff00;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        button::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(0, 255, 0, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.3s ease, height 0.3s ease;
            border-radius: 50%;
        }
        button:hover {
            background-color: rgba(0, 51, 0, 0.8);
            box-shadow: 0 0 10px #00ff00;
        }
        button:hover::after {
            width: 200%;
            height: 200%;
        }
        #feedback {
            width: 80%;
            max-width: 600px;
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            gap: 10px;
        }
        .meter {
            width: 30%;
            text-align: center;
        }
        .meter-label {
            font-size: 12px;
            margin-bottom: 5px;
            text-shadow: 0 0 3px #00ff00;
        }
        progress {
            width: 100%;
            height: 10px;
            background-color: #001100;
            border: 1px solid #00ff00;
        }
        progress::-webkit-progress-bar {
            background-color: #001100;
        }
        progress::-webkit-progress-value {
            background-color: #00ff00;
        }
        progress::-moz-progress-bar {
            background-color: #00ff00;
        }
        .graph {
            width: 100%;
            height: 50px;
            background-color: #001100;
            border: 1px solid #00ff00;
        }
    </style>
</head>
<body>
    <div id="simulation">
        <h2>Quantum Life Simulator - Matrix Edition</h2>
        <div class="controls">
            <button onclick="step()">Step</button>
            <button onclick="toggleRun()" id="runBtn">Start</button>
            <button onclick="reset()">Reset</button>
            <button onclick="randomize()">Randomize</button>
            <button onclick="toggleFullscreen()" id="fullscreenBtn">Fullscreen</button>
        </div>
        <div class="grid-container">
            <canvas id="grid"></canvas>
        </div>
        <div id="feedback">
            <div class="meter">
                <div class="meter-label">Alive Cells (%)</div>
                <progress id="aliveMeter" max="100" value="0"></progress>
            </div>
            <div class="meter">
                <div class="meter-label">Quantum Entropy</div>
                <progress id="entropyMeter" max="1" value="0"></progress>
            </div>
            <div class="meter">
                <div class="meter-label">Population Trend</div>
                <canvas id="populationGraph" class="graph"></canvas>
            </div>
            <div class="meter">
                <div class="meter-label">Mutations</div>
                <canvas id="mutationGraph" class="graph"></canvas>
            </div>
            <div class="meter">
                <div class="meter-label">Seekers</div>
                <canvas id="seekerGraph" class="graph"></canvas>
            </div>
        </div>
    </div>

    <script>
        const ROWS = 160;
        const COLS = 160;
        const DELTA = 0.1;
        let grid = [];
        let running = false;
        const canvas = document.getElementById('grid');
        const ctx = canvas.getContext('2d');
        const popGraphCanvas = document.getElementById('populationGraph');
        const popGraphCtx = popGraphCanvas.getContext('2d');
        const mutGraphCanvas = document.getElementById('mutationGraph');
        const mutGraphCtx = mutGraphCanvas.getContext('2d');
        const seekerGraphCanvas = document.getElementById('seekerGraph');
        const seekerGraphCtx = seekerGraphCanvas.getContext('2d');
        let populationHistory = [];
        let mutationHistory = [];
        let seekerHistory = [];
        let lastImageData = null; // For incremental rendering

        canvas.width = COLS;
        canvas.height = ROWS;
        popGraphCanvas.width = 100;
        popGraphCanvas.height = 50;
        mutGraphCanvas.width = 100;
        mutGraphCanvas.height = 50;
        seekerGraphCanvas.width = 100;
        seekerGraphCanvas.height = 50;

        function initializeGrid() {
            grid = [];
            for (let i = 0; i < ROWS; i++) {
                let row = [];
                for (let j = 0; j < COLS; j++) {
                    let a, b, color = { r: 0, g: 1, b: 0 };
                    if ((i === 20 && j === 21) || (i === 21 && j === 22) || (i === 22 && j === 20) || 
                        (i === 22 && j === 21) || (i === 22 && j === 22)) {
                        [a, b] = [0, 1];
                    } else {
                        [a, b] = [1, 0];
                    }
                    row.push({ a, b, color });
                }
                grid.push(row);
            }
            populationHistory = [];
            mutationHistory = [];
            seekerHistory = [];
            lastImageData = null;
            renderGrid();
            updateFeedback();
        }

        function renderGrid(changes = null) {
            if (!changes) {
                const imageData = ctx.createImageData(COLS, ROWS);
                const data = imageData.data;
                for (let i = 0; i < ROWS; i++) {
                    for (let j = 0; j < COLS; j++) {
                        const pAlive = grid[i][j].b * grid[i][j].b;
                        const v = Math.floor(255 * pAlive);
                        const { r, g, b } = grid[i][j].color;
                        const idx = (i * COLS + j) * 4;
                        data[idx] = v * r;
                        data[idx + 1] = v * g;
                        data[idx + 2] = v * b;
                        data[idx + 3] = 255;
                    }
                }
                ctx.putImageData(imageData, 0, 0);
                lastImageData = imageData;
            } else {
                const imageData = lastImageData || ctx.createImageData(COLS, ROWS);
                const data = imageData.data;
                for (const [i, j] of changes) {
                    const pAlive = grid[i][j].b * grid[i][j].b;
                    const v = Math.floor(255 * pAlive);
                    const { r, g, b } = grid[i][j].color;
                    const idx = (i * COLS + j) * 4;
                    data[idx] = v * r;
                    data[idx + 1] = v * g;
                    data[idx + 2] = v * b;
                    data[idx + 3] = 255;
                }
                ctx.putImageData(imageData, 0, 0);
                lastImageData = imageData;
            }
        }

        function computePN(pList, k) {
            const n = pList.length;
            let dp = Array(n + 1).fill(0);
            dp[0] = 1;
            for (const p of pList) {
                const newDp = Array(n + 1).fill(0);
                newDp[0] = dp[0] * (1 - p);
                for (let i = 1; i <= n; i++) {
                    newDp[i] = dp[i - 1] * p + dp[i] * (1 - p);
                }
                dp = newDp;
            }
            return dp[k];
        }

        function getNeighborsP(i, j) {
            const neighbors = [
                [i-1, j-1], [i-1, j], [i-1, j+1],
                [i, j-1],             [i, j+1],
                [i+1, j-1], [i+1, j], [i+1, j+1]
            ];
            const pList = [];
            for (const [ni, nj] of neighbors) {
                if (ni >= 0 && ni < ROWS && nj >= 0 && nj < COLS) {
                    pList.push(grid[ni][nj].b * grid[ni][nj].b);
                }
            }
            return pList;
        }

        function applyRotation(state, theta) {
            const cosHalf = Math.cos(theta / 2);
            const sinHalf = Math.sin(theta / 2);
            const aNew = state.a * cosHalf - state.b * sinHalf;
            const bNew = state.a * sinHalf + state.b * cosHalf;
            return [aNew, bNew];
        }

        function estimateClusterSize(i, j, color) {
            let size = 1;
            const neighbors = [
                [i-1, j], [i+1, j], [i, j-1], [i, j+1]
            ];
            for (const [ni, nj] of neighbors) {
                if (ni >= 0 && ni < ROWS && nj >= 0 && nj < COLS) {
                    const cell = grid[ni][nj];
                    if (cell.b * cell.b > 0.5 && cell.color.r === color.r && cell.color.g === color.g && cell.color.b === color.b) {
                        size++;
                    }
                }
            }
            return size * 2; // Rough approximation
        }

        function findNearestMutation(i, j) {
            let minDist = Infinity;
            let target = null;
            const step = 5; // Sample every 5th cell
            for (let ni = 0; ni < ROWS; ni += step) {
                for (let nj = 0; nj < COLS; nj += step) {
                    if (grid[ni][nj].color.r === 1 && grid[ni][nj].color.g === 0 && grid[ni][nj].color.b === 1 && grid[ni][nj].b * grid[ni][nj].b > 0.5) {
                        const dist = Math.sqrt((ni - i) ** 2 + (nj - j) ** 2);
                        if (dist < minDist) {
                            minDist = dist;
                            target = [ni, nj];
                        }
                    }
                }
            }
            return target;
        }

        function step() {
            const changes = [];
            for (let i = 0; i < ROWS; i++) {
                for (let j = 0; j < COLS; j++) {
                    const pCurrent = grid[i][j].b * grid[i][j].b;
                    const neighborsP = getNeighborsP(i, j);
                    const pN2 = computePN(neighborsP, 2);
                    const pN3 = computePN(neighborsP, 3);
                    let pTarget;

                    const isGreen = grid[i][j].color.r === 0 && grid[i][j].color.g === 1 && grid[i][j].color.b === 0;
                    const isPurple = grid[i][j].color.r === 1 && grid[i][j].color.g === 0 && grid[i][j].color.b === 1;
                    const isSeeker = grid[i][j].color.r === 0 && grid[i][j].color.g === 1 && grid[i][j].color.b === 1;

                    if (isPurple) {
                        pTarget = pN2 + pN3 + computePN(neighborsP, 4) * 0.5;
                    } else if (isGreen) {
                        pTarget = pN2 + pN3;
                    } else if (isSeeker) {
                        const hasPurpleNeighbor = neighborsP.some(p => p > 0.5 && grid[i-1]?.[j-1]?.color.r === 1);
                        pTarget = hasPurpleNeighbor ? 1 : pN2 + pN3;
                    } else {
                        pTarget = pN3;
                    }

                    const theta = (pTarget > pCurrent) ? DELTA : -DELTA;
                    const [aNew, bNew] = applyRotation(grid[i][j], theta);
                    if (grid[i][j].a !== aNew || grid[i][j].b !== bNew) {
                        grid[i][j].a = aNew;
                        grid[i][j].b = bNew;
                        changes.push([i, j]);
                    }

                    if (isGreen && pCurrent > 0.5 && Math.random() < 0.005) {
                        grid[i][j].color = { r: 1, g: 0, b: 1 };
                        changes.push([i, j]);
                    }

                    if (Math.random() < 0.01) {
                        const randomTheta = (Math.random() - 0.5) * 0.2;
                        const [aRand, bRand] = applyRotation(grid[i][j], randomTheta);
                        grid[i][j].a = aRand;
                        grid[i][j].b = bRand;
                        changes.push([i, j]);
                    }
                }
            }

            // Seeker and cluster logic
            for (let i = 0; i < ROWS; i += 2) { // Skip every other row for speed
                for (let j = 0; j < COLS; j += 2) {
                    const cell = grid[i][j];
                    if (cell.color.r === 0 && cell.color.g === 1 && cell.color.b === 0 && cell.b * cell.b > 0.5) {
                        const clusterSize = estimateClusterSize(i, j, { r: 0, g: 1, b: 0 });
                        if (clusterSize > 20 && Math.random() < 0.01) {
                            grid[i][j].color = { r: 0, g: 1, b: 1 };
                            changes.push([i, j]);
                        }
                    }
                    if (cell.color.r === 0 && cell.color.g === 1 && cell.color.b === 1 && cell.b * cell.b > 0.5) {
                        const target = findNearestMutation(i, j);
                        if (target) {
                            const [ti, tj] = target;
                            const di = Math.sign(ti - i);
                            const dj = Math.sign(tj - j);
                            if (grid[i + di]?.[j + dj] && grid[i + di][j + dj].b * grid[i + di][j + dj].b <= 0.5) {
                                grid[i + di][j + dj] = { a: 0, b: 1, color: { r: 0, g: 1, b: 1 } };
                                grid[i][j] = { a: 1, b: 0, color: { r: 0, g: 1, b: 0 } };
                                changes.push([i + di, j + dj], [i, j]);
                            }
                            if (grid[i + di]?.[j + dj]?.color.r === 1) {
                                grid[i + di][j + dj] = { a: 1, b: 0, color: { r: 0, g: 1, b: 0 } };
                                changes.push([i + di, j + dj]);
                            }
                        }
                    }
                }
            }

            renderGrid(changes);
            updateFeedback();
        }

        function updateFeedback() {
            let aliveCount = 0;
            let mutationCount = 0;
            let seekerCount = 0;
            let entropy = 0;
            const totalCells = ROWS * COLS;

            for (let i = 0; i < ROWS; i += 2) { // Sample for speed
                for (let j = 0; j < COLS; j += 2) {
                    const pAlive = grid[i][j].b * grid[i][j].b;
                    if (pAlive > 0.5) {
                        aliveCount += 4; // Adjust for sampling
                        if (grid[i][j].color.r === 1 && grid[i][j].color.g === 0 && grid[i][j].color.b === 1) {
                            mutationCount += 4;
                        } else if (grid[i][j].color.r === 0 && grid[i][j].color.g === 1 && grid[i][j].color.b === 1) {
                            seekerCount += 4;
                        }
                    }
                    entropy -= pAlive > 0 && pAlive < 1 ? pAlive * Math.log2(pAlive) + (1 - pAlive) * Math.log2(1 - pAlive) : 0;
                }
            }

            const alivePercent = (aliveCount / totalCells) * 100;
            const mutationPercent = (mutationCount / totalCells) * 100;
            const seekerPercent = (seekerCount / totalCells) * 100;
            entropy = entropy / (totalCells / 4); // Adjust for sampling

            document.getElementById('aliveMeter').value = alivePercent;
            document.getElementById('entropyMeter').value = entropy;

            populationHistory.push(alivePercent);
            if (populationHistory.length > popGraphCanvas.width) populationHistory.shift();
            popGraphCtx.clearRect(0, 0, popGraphCanvas.width, popGraphCanvas.height);
            popGraphCtx.beginPath();
            popGraphCtx.strokeStyle = '#00ff00';
            for (let i = 0; i < populationHistory.length; i++) {
                const y = popGraphCanvas.height - (populationHistory[i] / 100) * popGraphCanvas.height;
                i === 0 ? popGraphCtx.moveTo(i, y) : popGraphCtx.lineTo(i, y);
            }
            popGraphCtx.stroke();

            mutationHistory.push(mutationPercent);
            if (mutationHistory.length > mutGraphCanvas.width) mutationHistory.shift();
            mutGraphCtx.clearRect(0, 0, mutGraphCanvas.width, mutGraphCanvas.height);
            mutGraphCtx.beginPath();
            mutGraphCtx.strokeStyle = '#ff00ff';
            for (let i = 0; i < mutationHistory.length; i++) {
                const y = mutGraphCanvas.height - (mutationHistory[i] / 5) * mutGraphCanvas.height;
                i === 0 ? mutGraphCtx.moveTo(i, y) : mutGraphCtx.lineTo(i, y);
            }
            mutGraphCtx.stroke();

            seekerHistory.push(seekerPercent);
            if (seekerHistory.length > seekerGraphCanvas.width) seekerHistory.shift();
            seekerGraphCtx.clearRect(0, 0, seekerGraphCanvas.width, seekerGraphCanvas.height);
            seekerGraphCtx.beginPath();
            seekerGraphCtx.strokeStyle = '#00ffff';
            for (let i = 0; i < seekerHistory.length; i++) {
                const y = seekerGraphCanvas.height - (seekerHistory[i] / 5) * seekerGraphCanvas.height;
                i === 0 ? seekerGraphCtx.moveTo(i, y) : seekerGraphCtx.lineTo(i, y);
            }
            seekerGraphCtx.stroke();
        }

        function runSimulation() {
            if (running) {
                step();
                requestAnimationFrame(runSimulation);
            }
        }

        function toggleRun() {
            const runBtn = document.getElementById('runBtn');
            if (running) {
                running = false;
                runBtn.textContent = 'Start';
            } else {
                running = true;
                runBtn.textContent = 'Stop';
                requestAnimationFrame(runSimulation);
            }
        }

        function reset() {
            running = false;
            document.getElementById('runBtn').textContent = 'Start';
            initializeGrid();
        }

        function randomize() {
            for (let i = 0; i < ROWS; i++) {
                for (let j = 0; j < COLS; j++) {
                    if (Math.random() < 0.5) {
                        grid[i][j] = { a: 0, b: 1, color: { r: 0, g: 1, b: 0 } };
                    } else {
                        grid[i][j] = { a: 1, b: 0, color: { r: 0, g: 1, b: 0 } };
                    }
                }
            }
            renderGrid();
            updateFeedback();
        }

        function toggleFullscreen() {
            const elem = document.getElementById('simulation');
            if (!document.fullscreenElement) {
                elem.requestFullscreen().then(() => {
                    document.getElementById('fullscreenBtn').textContent = 'Exit Fullscreen';
                });
            } else {
                document.exitFullscreen().then(() => {
                    document.getElementById('fullscreenBtn').textContent = 'Fullscreen';
                });
            }
        }

        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                document.getElementById('fullscreenBtn').textContent = 'Fullscreen';
            }
        });

        initializeGrid();
    </script>
</body>
</html>